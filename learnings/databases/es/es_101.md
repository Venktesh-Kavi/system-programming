# 1. Elastic Search Architecture

Elastic Search internally uses Apache Lucene. To understand further we need to understand basics of Apache Lucene (Ref #2 Apache Lucene)

# 2. Elastic Search 101

## Document Oriented
Elastic search is document oriented - data is not just key value pairs (they are richer objects/complex data structures having dates, arrays, geo-locations etc..). Putting them in a row-column database is like squeezing them to a spreadsheet and reconstructing them back again. ES stores the objects as documents and also indexes the contents of each document.

## Basic Concepts
### Index, Type, Document
```http
PUT /megacorp/employee/1
```

### Search Lite
By default a `_search` returns top 10 results in the hits block

### Full Text Search (Mojo of ES)
- Find all employees who enjoy rock climbing
- Provides a score for each document in descending order of the score

```bash
curl -X GET "localhost:9200/megacorp/employee/_search?pretty" \
  -H 'Content-Type: application/json' \
  -d'{
    "query": {
        "match": {
            "about": "rock climbing"
        }
    }
}'
Phrase Search (Exact Match Search)

curl -X GET "localhost:9200/megacorp/employee/_search?pretty" -H 'Content-Type: application/json' -d'
{
    "query" : {
        "match_phrase" : {
            "about" : "rock climbing"
        }
    }
}'


Highlight Search (Highlight words matching with the search term)

curl -X GET "localhost:9200/megacorp/employee/_search?pretty" -H 'Content-Type: application/json' -d'
{
    "query" : {
        "match_phrase" : {
            "about" : "rock climbing"
        }
    },
    "highlight": {
        "fields" : {
            "about" : {}
        }
    }
}'


# 3. Elastic Search - Distributed System

## Master Node
- A cluster with one node is a master node, as it is elected as the master
- A master node is responsible for management operations on the cluster like, adding/deleting indexes or nodes from a cluster
- Master node is not involved in document level changes or searching
- Having a single master node can never become a bottle neck as the traffic grows

## Cluster Health
| Status | Description |
|--------|-------------|
| Green  | All primary & replica shards are active |
| Yellow | All primary shards are active but not all replica shards are active |
| Red    | Not all primary shards are active |

## Shards
### Overview
- Shard is a low level worker unit used to store a shard of data
- A shard is an instance of Apache Lucene (meaning it's a complete search engine on its own)
- Data is stored and indexed in shards, but applications interact with the index instead of shards directly
- Documents are stored in shards and the shards are allocated to nodes in the cluster
- ES automatically balances shards between available nodes as the cluster grows or shrinks

### Types and Capacity
#### Primary Shards
- Each document belongs to either a primary or replica shard
- The number of primary shards determines the max data an index can hold
- Primary shards can theoretically hold up to `Integer.MAX_VALUE(2^31 - 1) - 128` documents
  - Actual capacity depends on hardware, document size & complexity, and indexing configuration

#### Replica Shards
- Used for failover cases and serving search & retrieval operations
- Number of primary shards is fixed at creation time
- Number of replica shards can be adjusted as needed
- Default configuration: 5 primary shards
- Adding replica nodes triggers shard rebalancing
  - Example: With 3 primary and 3 replica shards, a 6-node cluster can give each shard 100% dedicated node resources

## Node Discovery
### Unicast vs Multicast
- Nodes on same machine with same `cluster.name` join the cluster via unicast
- Multicast discovery possible through plugins (not recommended for production)
  - Avoids accidental cluster joins from errant multicast pings

### Unicast Configuration
- Provide ES a list of nodes to contact
- New node joining process:
  1. Contacts a member from the list
  2. Receives cluster details
  3. Contacts master to join cluster
- Best practice: Directly specify master nodes in configuration

```yaml
discovery.zen.ping.unicast.hosts: ["host1", "host2:port"]
```


## Cluster Health Check Example

### API Request
```bash
curl -XGET "https://vpc-dso-devops-logging-01-zc6i4gzpbplointjiep7bkhuhy.ap-south-1.es.amazonaws.com/_cluster/health?pretty" \
  --header 'Authorization: Basic dWF0X2ludGVyb3Bfc3ZjOnIjaG05M35BalY1TThrVkBzZQ=='
```

### Sample Response
```json
{
  "cluster_name" : "155577958684:dso-devops-logging-01",
  "status" : "yellow",
  "timed_out" : false,
  "number_of_nodes" : 7,
  "number_of_data_nodes" : 4,
  "discovered_master" : true,
  "active_primary_shards" : 2458,
  "active_shards" : 3992,
  "relocating_shards" : 0,
  "initializing_shards" : 0,
  "unassigned_shards" : 8,
  "delayed_unassigned_shards" : 0,
  "number_of_pending_tasks" : 0,
  "number_of_in_flight_fetch" : 0,
  "task_max_waiting_in_queue_millis" : 0,
  "active_shards_percent_as_number" : 99.8
}


Document Meta
_index - where the document lives
_type - class of object the document represents
_id - unique identifier of the document

Storing unrelated documents in an index is an anti-pattern.
Data can be loosely grouped into an index. Define sub-partitions in data using type. Eg.. product can be an index, electronics, clothing etc.., can be a type.
Elastic search exposes a feature called types, which allows to logically partition data in an index. Documents in different types can a different fields but its best to make them as similar as possible.

ID Generation Mechanism

Autogenerated IDs are 20 character long, URL-safe, Base64-encoded GUID strings. These GUIDs are generated from a modified FlakeID scheme which allows multiple nodes to be generating unique IDs in parallel with essentially zero chance of collision.
(UUID & GUID are synonyms)

Updating a Whole Document
Updating a document in ES is not possible, we can only reindex or replace the document using the Index API
Notice the version being incremented from 1 to 2. Created is set to false (as already a doc was existing)
Internally elastic search marks the old document as deleted and adds an entirely new document.
Old documents don’t disappear immediately, although we won’t be able to access them.
We can perform partial updates using Update API. Internally ES does the same thing.


PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}



{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 2,
  "created":   false 
}

Handling Large Number of Updates From CDC

Batching
Instead of continuously streaming individual updates, batch them and index in bulk to reduce the number of operations.
Increase the refresh_interval for the index to reduce the frequency of segment creation

{ "index": { "refresh_interval": "30s" } }
Optimize Merge Policies: Adjust the merge.policy settings to handle frequent updates better. For example:
Increase max_merge_at_once to handle larger merges.
Increase segments_per_tier to limit the number of segments in an index tier.
Use index.lifecycle.management (ILM): Implement ILM to optimize indexing and merging policies based on document lifecycle requirements.
Consider splitting indices into smaller, time-based chunks (e.g., daily indices) to reduce the impact of updates on older data.

Creating  a Document

Easiest way to create a document, is to allow ES to auto generate the ID
POST index/type {..} (data) 
If we already know the ID to use PUT index/type/123?op_type=create or index/type/123/_create
Optimistic Concurrency Control

Elastic search is a distributed document store and it asynchronous and concurrently syncs the data across different shards in different nodes.
In order to guarantee out of sequence results or the older data replacing the newer ones, es provides versions out of the box in the document meta
Making use of versions to avoid conflicts: https://www.elastic.co/guide/en/elasticsearch/guide/current/optimistic-concurrency-control.html

Partial Updates
Partial updates is sugar coated abstraction of read-modify-reindex process of the update api.

Multiple Requests

Multiple requests (Like get) can be combined in a single calls, reducing network latency
Using GET /_mget

Cheaper in Bulk
Format
{ action: { metadata }}\n
{ request body        }\n

POST /_bulk
{ "delete": { "_index": "website", "_type": "blog", "_id": "123" }} 
{ "create": { "_index": "website", "_type": "blog", "_id": "123" }}
{ "title":    "My first blog post" }
{ "index":  { "_index": "website", "_type": "blog" }}
{ "title":    "My second blog post" }
{ "update": { "_index": "website", "_type": "blog", "_id": "123", "_retry_on_conflict" : 3} }
{ "doc" : {"title" : "My updated blog post"} } 



#4 Distributed Document Store

Routing a document to a particular shard

shard = hash(routing) % number_of_primary_shards
Routing key is the _id of the document
Returns a reminder from 0 to no of primary shards - 1
This is the reason we cannot allocate new primary shards dynamically as it might result in recomputing and routing multiple impacted keys to different shards.

Exact vs Full Text Search
Data in ES can be broadly divided into: exact and full text
Exact Match Examples: examples are searching by date/userId etc.., (search by 2014 is not equal to search by 2014-01-02. Similarly search by “Foo” is not equal to “foo”). It should exactly match.
Full text - refers to textual data, usually written in human readable language like text of a tweet or body of an email.
Querying full-text data is much more subtle. We are not just asking, “Does this document match the query” but “How well does this document match the query?” In other words, how relevant is this document to the given query?
We seldom want to match the whole full-text field exactly. Instead, we want to search within text fields. Not only that, but we expect search to understand our intent:
A search for the UK should also return documents mentioning the United Kingdom.
A search for jump should also match jumped, jumps, jumping, and perhaps even leap.
Johnny Walker should match Johnnie Walker, and johnnie depp should match Johnny Depp.
fox news hunting should return stories about hunting on Fox News, while fox hunting news should return news stories about fox hunting.
To facilitate these types of queries on full-text fields, Elasticsearch first analyzes the text, and then uses the results to build an inverted index.

Full text is often referred to as unstructured data, which is a misnomer—​natural language is highly structured. The problem is that the rules of natural languages are complex, which makes them difficult for computers to parse correctly. For instance, consider this sentence:

May is fun but June bores me.
Does it refer to months or to people?



Analysis & Analyzers
When a document is indexed or a search query is sent for full text search


#4 Apache Lucene





# Glossary

| Term | Definition |
|------|------------|
| Searching | The process of providing an input to search across a set of docs/data |
| Ranking | Sorting the search result based on the relevance score gained for a given search input |
| Indexing | The act of storing data in ES |
| Index (noun) | Like a database in RDBMS; a space to store related data; logical namespace pointing to physical shards |
| Index (verb) | To store a document in an index |
| Node | A running instance of Elastic Search |
| Cluster | A group of nodes with the same cluster.name |
| Document | Root object or top level object serialized into JSON and stored in ES under a unique ID |
| Object | JSON object |