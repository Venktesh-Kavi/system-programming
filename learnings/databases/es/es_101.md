# 1. Elastic Search Architecture

Elastic Search internally uses Apache Lucene. To understand further we need to understand basics of Apache Lucene (Ref #2 Apache Lucene)

# 2. Elastic Search 101

## Document Oriented
Elastic search is document oriented - data is not just key value pairs (they are richer objects/complex data structures having dates, arrays, geo-locations etc..). Putting them in a row-column database is like squeezing them to a spreadsheet and reconstructing them back again. ES stores the objects as documents and also indexes the contents of each document.

## Basic Concepts
### Index, Type, Document
```http
PUT /megacorp/employee/1
```

### Search Lite
By default a `_search` returns top 10 results in the hits block

### Full Text Search (Mojo of ES)
- Find all employees who enjoy rock climbing
- Provides a score for each document in descending order of the score

```bash
curl -X GET "localhost:9200/megacorp/employee/_search?pretty" \
  -H 'Content-Type: application/json' \
  -d'{
    "query": {
        "match": {
            "about": "rock climbing"
        }
    }
}'
Phrase Search (Exact Match Search)

curl -X GET "localhost:9200/megacorp/employee/_search?pretty" -H 'Content-Type: application/json' -d'
{
    "query" : {
        "match_phrase" : {
            "about" : "rock climbing"
        }
    }
}'


Highlight Search (Highlight words matching with the search term)

curl -X GET "localhost:9200/megacorp/employee/_search?pretty" -H 'Content-Type: application/json' -d'
{
    "query" : {
        "match_phrase" : {
            "about" : "rock climbing"
        }
    },
    "highlight": {
        "fields" : {
            "about" : {}
        }
    }
}'


# 3. Elastic Search - Distributed System

## Master Node
- A cluster with one node is a master node, as it is elected as the master
- A master node is responsible for management operations on the cluster like, adding/deleting indexes or nodes from a cluster
- Master node is not involved in document level changes or searching
- Having a single master node can never become a bottle neck as the traffic grows

## Cluster Health
| Status | Description |
|--------|-------------|
| Green  | All primary & replica shards are active |
| Yellow | All primary shards are active but not all replica shards are active |
| Red    | Not all primary shards are active |

## Shards
### Overview
- Shard is a low level worker unit used to store a shard of data
- A shard is an instance of Apache Lucene (meaning it's a complete search engine on its own)
- Data is stored and indexed in shards, but applications interact with the index instead of shards directly
- Documents are stored in shards and the shards are allocated to nodes in the cluster
- ES automatically balances shards between available nodes as the cluster grows or shrinks

### Types and Capacity
#### Primary Shards
- Each document belongs to either a primary or replica shard
- The number of primary shards determines the max data an index can hold
- Primary shards can theoretically hold up to `Integer.MAX_VALUE(2^31 - 1) - 128` documents
  - Actual capacity depends on hardware, document size & complexity, and indexing configuration

#### Replica Shards
- Used for failover cases and serving search & retrieval operations
- Number of primary shards is fixed at creation time
- Number of replica shards can be adjusted as needed
- Default configuration: 5 primary shards
- Adding replica nodes triggers shard rebalancing
  - Example: With 3 primary and 3 replica shards, a 6-node cluster can give each shard 100% dedicated node resources

## Node Discovery
### Unicast vs Multicast
- Nodes on same machine with same `cluster.name` join the cluster via unicast
- Multicast discovery possible through plugins (not recommended for production)
  - Avoids accidental cluster joins from errant multicast pings

### Unicast Configuration
- Provide ES a list of nodes to contact
- New node joining process:
  1. Contacts a member from the list
  2. Receives cluster details
  3. Contacts master to join cluster
- Best practice: Directly specify master nodes in configuration

```yaml
discovery.zen.ping.unicast.hosts: ["host1", "host2:port"]
```


## Cluster Health Check Example

### API Request
```bash
curl -XGET "https://vpc-dso-devops-logging-01-zc6i4gzpbplointjiep7bkhuhy.ap-south-1.es.amazonaws.com/_cluster/health?pretty" \
  --header 'Authorization: Basic dWF0X2ludGVyb3Bfc3ZjOnIjaG05M35BalY1TThrVkBzZQ=='
```

### Sample Response
```json
{
  "cluster_name" : "155577958684:dso-devops-logging-01",
  "status" : "yellow",
  "timed_out" : false,
  "number_of_nodes" : 7,
  "number_of_data_nodes" : 4,
  "discovered_master" : true,
  "active_primary_shards" : 2458,
  "active_shards" : 3992,
  "relocating_shards" : 0,
  "initializing_shards" : 0,
  "unassigned_shards" : 8,
  "delayed_unassigned_shards" : 0,
  "number_of_pending_tasks" : 0,
  "number_of_in_flight_fetch" : 0,
  "task_max_waiting_in_queue_millis" : 0,
  "active_shards_percent_as_number" : 99.8
}


## Document Metadata

### Core Metadata Fields
| Field | Description |
|-------|-------------|
| `_index` | Where the document lives |
| `_type` | Class of object the document represents |
| `_id` | Unique identifier of the document |

### Best Practices
- Avoid storing unrelated documents in an index (anti-pattern)
- Group related data into indices
- Use types for logical sub-partitions
  - Example: `product` index can have types like `electronics`, `clothing`
- Types allow logical partitioning within an index
  - Documents in different types can have different fields
  - Best practice: Keep field structures similar across types

## ID Generation

### Autogenerated IDs
- 20 character long
- URL-safe, Base64-encoded GUID strings
- Based on modified FlakeID scheme
- Enables parallel ID generation across nodes
- Near-zero collision probability

> Note: UUID and GUID are synonymous terms

## Document Updates

### Full Document Updates
- Direct document updates are not possible in ES
- Documents must be reindexed or replaced using the Index API
- Version number increments with each update
- `created` flag is `false` for updates to existing documents

### Internal Process
- Old document is marked as deleted
- New document is added
- Old documents remain temporarily but are inaccessible

### Partial Updates
- Available through Update API
- Internally performs same read-modify-write process

### Example Update
```http
PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}
```

#### Response
```json
{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "123",
  "_version": 2,
  "created":  false 
}
```

## Handling Large Number of Updates (CDC)

### Optimization Strategies

#### 1. Batching
- Batch updates instead of streaming individually
- Reduces number of operations
- Increase refresh interval to reduce segment creation:
```json
{ "index": { "refresh_interval": "30s" } }
```

#### 2. Merge Policy Optimization
- Adjust `merge.policy` settings for better update handling:
  - Increase `max_merge_at_once` for larger merges
  - Increase `segments_per_tier` to limit index tier segments

#### 3. Index Lifecycle Management
- Implement ILM to optimize indexing and merging policies
- Consider time-based index splitting
  - Example: Use daily indices
  - Reduces impact on older data

## Document Creation

### Creating Documents
- **Auto-generated ID** (Recommended)
  ```http
  POST index/type
  { "data": "content" }
  ```
- **Custom ID**
  ```http
  PUT index/type/123?op_type=create
  # or
  PUT index/type/123/_create
  ```

### Optimistic Concurrency Control
- ES is a distributed, asynchronous document store
- Version control prevents out-of-sequence updates
- Version numbers included in document metadata
- [Documentation on version control](https://www.elastic.co/guide/en/elasticsearch/guide/current/optimistic-concurrency-control.html)

## Document Operations

### Partial Updates
- Simplified abstraction over read-modify-reindex process
- Handled by Update API

### Batch Operations

#### Multi-Get
- Combine multiple GET requests into single call
- Reduces network latency
- Uses `GET /_mget` endpoint

#### Bulk Operations
- Format:
  ```json
  { action: { metadata }}
  { request body        }
  ```

##### Bulk API Example
```json
POST /_bulk
{ "delete": { "_index": "website", "_type": "blog", "_id": "123" }}
{ "create": { "_index": "website", "_type": "blog", "_id": "123" }}
{ "title": "My first blog post" }
{ "index": { "_index": "website", "_type": "blog" }}
{ "title": "My second blog post" }
{ "update": { "_index": "website", "_type": "blog", "_id": "123", "_retry_on_conflict": 3 }}
{ "doc": { "title": "My updated blog post" }}
```



# 4. Distributed Document Store

## Document Routing

### Shard Selection Formula
```
shard = hash(routing) % number_of_primary_shards
```

### Key Points
- Routing key is the document's `_id`
- Returns value between 0 and (number_of_primary_shards - 1)
- Primary shard count is fixed at index creation
  - Cannot be changed dynamically
  - Would require recomputing and rerouting all documents

## Search Types

### 1. Exact Search
- Used for precise matching
- Examples: dates, userIds
- No fuzzy matching
  - `2014` ≠ `2014-01-02`
  - `Foo` ≠ `foo`

### 2. Full Text Search
- For human-readable content (tweets, emails, etc.)
- Focuses on relevance, not just matches
  - "How well does this document match?" vs "Does it match?"

#### Intelligent Matching
- Understands variations:
  - UK → United Kingdom
  - jump → jumped, jumps, jumping, leap
  - Johnny/Johnnie Walker

#### Context Awareness
- Understands phrase context:
  - "fox news hunting" → hunting on Fox News
  - "fox hunting news" → news about fox hunting

#### Implementation
- Text analysis phase
- Builds inverted index for efficient searching

### Natural Language Complexity
- Full text ≠ unstructured data
- Natural language has inherent structure
- Challenge: Complex language rules

#### Example Ambiguity
```
May is fun but June bores me.
```
- Could refer to months or people
- Context determines meaning

## Analysis & Analyzers
- Used during document indexing
- Applied to search queries for full text search

# 4. Apache Lucene
*Core search engine library used by Elasticsearch*





# Glossary

| Term | Definition |
|------|------------|
| Searching | The process of providing an input to search across a set of docs/data |
| Ranking | Sorting the search result based on the relevance score gained for a given search input |
| Indexing | The act of storing data in ES |
| Index (noun) | Like a database in RDBMS; a space to store related data; logical namespace pointing to physical shards |
| Index (verb) | To store a document in an index |
| Node | A running instance of Elastic Search |
| Cluster | A group of nodes with the same cluster.name |
| Document | Root object or top level object serialized into JSON and stored in ES under a unique ID |
| Object | JSON object |